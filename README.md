# vk_education_deep_python
homework for the spring course 2023

## Домашнее задание #01 (введение, тестирование)

### 1. Функция оценки сообщения
Реализовать функцию predict_message_mood, которая приниамает на вход строку, экземпляр модели SomeModel и пороги хорошести.
Функция возвращает:
- "неуд", если предсказание модели меньше bad_threshold
- "отл", если предсказание модели больше good_threshold
- "норм" в остальных случаях
### 2. Написать генератор для чтения и фильтрации файла
Есть текстовый файл, который может не помещаться в память.
В каждой строке файла фраза или предложение: набор слов, разделенных пробелами (знаков препинания нет).
Генератор должен принимать на вход имя файла или файловый объект и список слов для поиска.
Генератор перебирает строки файла и возвращает только те из них (строку целиком), где встретилось хотя бы одно из слов для поиска.
Поиск должен выполняться по полному совпадению слова без учета регистра.
### 3. Тесты в отдельном модуле для каждого пункта


## Домашнее задание #02

### 1. Написать функцию, которая в качестве аргументов принимает строку json, список полей, которые необходимо обработать, список имён, которые нужно найти и функцию-обработчика имени, который срабатывает, когда в каком-либо поле было найдено ключевое имя.
Функция, должна принимать строку, в которой содержится json, и произвести парсинг этого json.
Упростим немного и представим, что json представляет из себя только коллекцию ключей-значений.
Причём ключами и значениями являются только строки.
### 2. Использовать mock-объект при тестировании
### 3. Узнать степень покрытия тестами с помощью библиотеки coverage


## Домашнее задание #03 (объектная модель, ООП)

### 1. Реализовать класс CustomList наследованием от list
При этом:

- CustomList должен наследоваться от встроенного списка `list`;
- экземпляры CustomList можно складывать друг с другом и с обычными списками:
- экземпляры CustomList можно вычитать друг с другом и с обычными списками:
- результатом сложения/вычитания должен быть новый кастомный список;
- при сложении/вычитании списков разной длины отсутствующие элементы меньшего списка считаются нулями;
- при сравнении (==, !=, >, >=, <, <=) экземмпляров CustomList должна сравниваться сумма элементов списков (сравнение с list не нужно);
- должен быть переопределен str, чтобы выводились элементы списка и их сумма;
- списки можно считать всегда числовыми.
### 2. Тесты CustomList в отдельном модуле


## Домашнее задание #04 (дескрипторы, метаклассы, ABC)

### 1. Метакласс, который в начале названий всех атрибутов и методов, кроме магических, добавляет префикс "custom_"
  Подменяться должны атрибуты класса и атрибуты экземпляра класса, в том числе добавленные после выполнения конструктора.
### 2. Дескрипторы с проверками типов и значений данных
  Нужно сделать три дескриптора для какой-то области интереса.
### 3. Тесты метакласса и дескрипторов


## Домашнее задание #05 (стандартная библиотека)

### 1. LRU-кэш
Сложность решения по времени в среднем должна быть константной O(1).
Реализация любым способом без использования OrderedDict.
### 2. Тесты в отдельном модуле

## Домашнее задание #06 (потоки, процессы)

### 1. Клиент-серверное приложение для обкачки набора урлов
#### Cервер
master-worker cервер для обработки запросов от клиента.
Алгоритм должен быть следующим:
  - Мастер и воркеры это разные потоки в едином приложении;
  - Количество воркеров задается при запуске;
  - Мастер слушает порт, на который клиент будет по TCP отправлять урлы для обкачки;
  - Мастер принимает запроc и передает его одному из воркеров;
  - Воркер читает url от клиента;
  - Воркер обкачивает url по http и возвращает клиенту топ K самых частых слов и их частоту в формате json {"word1": 10, "word2": 5};
  - После каждого обработанного урла сервер должен вывести статистику: сколько урлов было обработано на данный момент суммарно всеми воркерами;

`python server.py -w 10 -k 7` (сервер использует 10 воркеров для обкачки и отправляет клиенту топ-7 частых слов)
#### Клиент
Утилита, отправляющая запросы с урлами серверу по TCP в несколько потоков.
Нужно сделать следующее:
  - Подготовить файл с запросами (порядка 100 разных url);
  - На вход клиенту передаётся два аргумента --- файл с URL'ами и M (количество потоков);
  - Клиент создает M потоков, отправляет запросы на сервер в каждом потоке и печатает ответ сервера в стандартый вывод, например: `xxx.com: {'word1': 100, 'word2': 50}`.

`python client.py 10 urls.txt`.

Все действия должны быть выделены в классы/функции.
### 2. Тесты в отдельном модуле

## Домашнее задание #07 (async)

### 1. Скрипт для асинхронной обкачки урлов
Написать скрипт для обкачки списка урлов с возможностью задавать количество одновременных запросов, используя асинхронное программирование.
Клиент можно использовать любой, например, из aiohttp.
### 2. Тесты в отдельном модуле

## Домашнее задание #08 (память, профилирование)

### 1. Сравнение использования weakref и слотов
Нужно придумать свои типы с несколькими атрибутами:
- класс с обычными атрибутами
- класс со слотами
- класс с атрибутами weakref
Для каждого класса создается большое число экземпляров и замеряется (сравнивается):
- время создания пачки экземпляров
- время чтения/изменения атрибутов
Результаты замеров оформляются скриншотами c описанием и выводом.
### 2. Профилирование
Провести профилирование вызовов и памяти для кода из пункта 1.
Результаты оформляются скриншотами c описанием.
### 3. Декоратор для профилирования
Применение декоратора к функции должно выполнять прoфилирование (cProfile) всех вызовов данной функции.
Вызов метода `.print_stat()` должен выводить единую таблицу со статистикой профилирования суммарно по всем вызовам функции.


## Домашнее задание #09 (логирование)

### 1. Логирование LRUCache
Добавить логирование разного уровня в файл cache.log для LRUCache.
- По аргументу командной строки "-s" дополнительно логировать в stdout с отдельным форматированием.
- По аргументу командной строки "-f" нужно применять кастомный фильтр, например, отбрасывающий записи c четным числом слов или что-то свое.
- "-s" и "-f" могут указываеться в одном запуске и должны работать вместе в таком случае.

Логирование должно покрывать как минимум следующие случаи:
- get существующего ключа
- get отсутствующего ключа
- set отсутствующего ключа
- set отсутствующего ключа, когда достигнута ёмкость
- set существующего ключа
- различные debug записи в дополнение и в зависимости от реализации
При запуске модуля должны выполняться все перечисленные операции с кэшом (через функцию в `if __name__ == "__main__"`).

## Домашнее задание #10 (Расширения на C)

### 1. Реализовать библиотеку для парсинга и сериализации json (с помощью C API)
- Нужно написать модуль cjson, который имел бы хотя бы два метода: loads и dumps;
- Методу loads на вход подаётся строка в формате JSON. Ограничения:
    * JSON-сообщение в виде набор пар ключ-значение (читай как python-словарь);
    * Ключём в JSON **всегда** является строка в двойных кавычках;
    * Значением может выступать либо число, либо строка. Если захотелось приключений, то можно сделать поддержку и других типов;
    * Если входная строка не является JSON-объектом, то возвращаем исключение
    * Возвращать мы должны объект типа dict.
- Методу dumps в качестве аргумента передаётся объект типа dict и возвращает строку. Ограничения как у loads только наоборот;

### 2. Написать Makefile
При выполнении команды make происходит следующее:
- Создаваться и активироваться виртуальное окружение в папку venv с установкой всех необходимых библиотек;
- Компиляция кода и установка модуля (выполнялся бы setup.py install);
- Должна быть цель test, которая запустит тесты (перед запуском цели test всегда будет выполняться команда make).
### 3. Написать тесты
Нужно написать тесты корректности работы методов loads и dumps на языке Python, проверяющие корректность парсинга и дампа (с помощью unittest);

### 4. Написать тест производительности
Сравнивать скорость работы своей реализации с json и ujson на одних и тех же данных. Данные должны быть большие (как количество JSON, так и размер каждого JSON).

Требование: выполнение тестов не менее 100 мс.
